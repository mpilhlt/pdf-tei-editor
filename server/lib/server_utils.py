import datetime
import os
from flask import current_app
import uuid
from webdav4.client import Client, ResourceAlreadyExists
from datetime import datetime, timezone, timedelta
import io
import requests


class ApiError(RuntimeError):
    """
    Custom exception class for API-specific errors.

    Attributes:
        message -- explanation of the error
        status_code -- the HTTP (or other) status code associated with the error
        
    """
    def __init__(self, message, status_code=500):
        super().__init__(message)
        self.status_code = status_code


def make_timestamp():
    now = datetime.now()
    formatted_time = now.strftime("%Y-%m-%d %H:%M:%S")
    return formatted_time

def get_data_file_path(path):
    data_root = current_app.config["DATA_ROOT"]
    return os.path.join(data_root, safe_file_path(path))

def safe_file_path(file_path):
    """
    Removes any non-alphabetic leading characters for safety, and strips the "/data" prefix
    """
    if not file_path:
        raise ApiError("Invalid file path: path is empty", status_code=400)
    
    while len(file_path) > 0 and not file_path[0].isalpha():
        file_path = file_path[1:]
    if not file_path.startswith("data/"):
        raise ApiError(f"Invalid file path: {file_path}", status_code=400) 
    return file_path.removeprefix('data/')

def get_server_id(current_app):
    """
    Returns a unique server ID which is generated by a UUID and is persisted
    across server restarts. It is saved in the data directory.
    """
    data_root = current_app.config["DATA_ROOT"]
    server_id_file = os.path.join(data_root, "server_id.txt")
    if os.path.exists(server_id_file):
        with open(server_id_file, 'r') as f:
            server_id = f.read().strip()
    else:
        server_id = str(uuid.uuid4())
        with open(server_id_file, 'w') as f:
            f.write(server_id)
    return server_id

def remove_obsolete_marker_if_exists(file_path, logger):
    """
    Checks for a .deleted marker corresponding to a file path and removes it if it exists.
    """
    marker_path = str(file_path) + ".deleted"
    if os.path.exists(marker_path):
        logger.info(f"Removing obsolete deletion marker at {marker_path} before writing file.")
        os.remove(marker_path)

#
# Locking mechanism
#

LOCK_TIMEOUT_SECONDS = 60

def get_webdav_client():
    """Initializes and returns a WebDAV client from environment variables."""
    if not current_app.config.get('WEBDAV_ENABLED'):
        return None
    return Client(
        base_url=os.environ['WEBDAV_HOST'],
        auth=(os.environ['WEBDAV_USER'], os.environ['WEBDAV_PASSWORD'])
    )

def _read_lock_id(client, lock_path):
    """Downloads and reads the server ID from a lock file."""
    file_obj = io.BytesIO()
    client.download_fileobj(lock_path, file_obj)
    file_obj.seek(0)
    return file_obj.read().decode('utf-8')

def get_lock_path(file_path):
    """Constructs the remote lock file path."""
    remote_root = os.environ['WEBDAV_REMOTE_ROOT']
    # We use the relative path of the file to create a unique lock file name
    lock_file_name = safe_file_path(file_path).replace('/', '_') + '.lock'
    return f"{remote_root.rstrip('/')}/locks/{lock_file_name}"

def is_lock_stale(lock_mtime):
    """Checks if a lock's modification time is older than the timeout."""
    if not lock_mtime:
        return True
    return (datetime.now(timezone.utc) - lock_mtime) > timedelta(seconds=LOCK_TIMEOUT_SECONDS)

def acquire_lock(file_path):
    """
    Tries to acquire a lock for a given file. Returns True on success, False on failure.
    Raises ApiError for configuration issues.
    """
    
    current_app.logger.debug(f"Acquiring lock for {file_path}")
    
    client = get_webdav_client()
    if not client:
        raise ApiError("WebDAV is not configured, cannot acquire lock.", status_code=500)

    lock_path = get_lock_path(file_path)
    server_id = get_server_id(current_app)
    
    def upload_lock(overwrite=True):
        lock_content = io.BytesIO(server_id.encode('utf-8'))
        client.upload_fileobj(lock_content, lock_path, overwrite=overwrite)

    try:
        # Atomically create the lock file. Fails if it already exists.
        upload_lock(overwrite=False)
        current_app.logger.info(f"Lock acquired for {file_path} by session {server_id}")
        return True
    except (ResourceAlreadyExists, requests.exceptions.HTTPError):
        # Lock exists. Check if it's ours or if it's stale.
        try:
            info = client.info(lock_path)
            existing_lock_id = _read_lock_id(client, lock_path)
            
            if existing_lock_id == server_id:
                # It's our own lock, just refresh it.
                upload_lock(overwrite=True)
                current_app.logger.info(f"Refreshed own lock for {file_path}")
                return True

            if is_lock_stale(info.get('modified')):
                # Lock is stale, take it over.
                upload_lock(overwrite=True)
                current_app.logger.warning(f"Took over stale lock for {file_path} and server id {server_id} from session {existing_lock_id}")
                return True
            else:
                # Lock is held by another active session.
                current_app.logger.warning(f"Failed to acquire lock for {file_path} and server id {server_id}. Held by {existing_lock_id}.")
                return False
        except Exception as e:
            current_app.logger.error(f"Error checking existing lock for {file_path}: {e}")
            return False
        
def release_lock(file_path):
    """Releases the lock for a given file if it is held by the current session."""
    client = get_webdav_client()
    if not client:
        return # If WebDAV is off, there are no locks to release.

    lock_path = get_lock_path(file_path)
    server_id = get_server_id(current_app)

    try:
        info = client.info(lock_path)
        if info:
            existing_lock_id = _read_lock_id(client, lock_path)
            if existing_lock_id == server_id:
                client.remove(lock_path)
                current_app.logger.info(f"Lock released for {file_path} by session {server_id}")
                return True
            else:
                # This is an unexpected state. Fail loudly.
                raise ApiError(f"Session {server_id} attempted to release a lock owned by {existing_lock_id}", status_code=409)
    except FileNotFoundError:
        # Lock already gone, which is a success state.
        current_app.logger.info(f"Attempted to release lock for {file_path}, but it was already gone.")
        return True
    except Exception as e:
        message = f"Error releasing lock for {file_path}: {str(e)}"
        current_app.logger.error(message)
        # Re-raise as an ApiError for consistent handling by the endpoint.
        if isinstance(e, ApiError):
            raise e
        else:
            raise ApiError(message, status_code=500)
    

def purge_stale_locks():
    """Removes all stale lock files from the WebDAV server."""
    client = get_webdav_client()
    if not client:
        return 0
        
    remote_root = os.environ['WEBDAV_REMOTE_ROOT']
    locks_dir = f"{remote_root.rstrip('/')}/locks/"
    
    try:
        if not client.exists(locks_dir):
            client.mkdir(locks_dir)
    except Exception as e:
        current_app.logger.error(f"Could not create remote locks directory '{locks_dir}': {e}")
        return 0

    purged_count = 0
    try:
        lock_files = client.ls(locks_dir, detail=True)
        for lock in lock_files:
            if lock['type'] == 'file' and is_lock_stale(lock.get('modified')):
                try:
                    client.remove(lock['name'])
                    current_app.logger.info(f"Purged stale lock file: {lock['name']}")
                    purged_count += 1
                except Exception as e:
                    current_app.logger.error(f"Failed to purge stale lock {lock['name']}: {e}")
    except FileNotFoundError:
        # No locks directory, nothing to purge.
        pass
    except Exception as e:
        current_app.logger.error(f"Error listing or purging stale locks: {e}")
    
    return purged_count

def get_all_active_locks():
    """Fetches all non-stale lock files and returns a map of locked_file_path -> server_id."""
    client = get_webdav_client()
    if not client:
        return {}

    remote_root = os.environ['WEBDAV_REMOTE_ROOT']
    locks_dir =  f"{remote_root.rstrip('/')}/locks/"
    if not client.exists(locks_dir):
        try:
            client.mkdir(locks_dir)
        except Exception as e:
            current_app.logger.error(f"Could not create remote locks directory '{locks_dir}': {e}")
            return {}
        
    active_locks = {}

    try:
        lock_files = client.ls(locks_dir, detail=True)
        for lock in lock_files:
            if lock['type'] == 'file' and not is_lock_stale(lock.get('modified')):
                try:
                    server_id = _read_lock_id(client, lock['name'])
                    # The lock file name is the original file path with slashes replaced by underscores
                    original_file_path_part = lock['name'].split('/')[-1].replace('.lock', '')
                    original_file_path = original_file_path_part.replace('_', '/')
                    active_locks["/data/" + original_file_path] = server_id
                except Exception as e:
                    current_app.logger.error(f"Error reading lock file {lock['name']}: {e}")
    except FileNotFoundError:
        return {}
    except Exception as e:
        current_app.logger.error(f"Error listing active locks: {e}")
    
    return active_locks

def check_lock(file_path):
    """Checks if a single file is locked by another session."""
    active_locks = get_all_active_locks()
    server_id = get_server_id(current_app)
    
    if file_path in active_locks and active_locks[file_path] != server_id:
        return { "is_locked": True }
    
    return { "is_locked": False }